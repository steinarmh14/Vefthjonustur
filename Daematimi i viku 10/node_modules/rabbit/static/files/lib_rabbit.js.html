<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/rabbit.js - Rabbit</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://a3d72a45d111006ec192-ec5b80a12b0b09b4d52373336afb4254.r80.cf1.rackcdn.com/usability-dynamics.png" title="Rabbit"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/rabbit.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Rabbit
 *
 * The Rabbit works, or else the Rabbit gets fucked; proper fucked, that is
 *
 * ## Events
 * - connection: General connection event - could be an error or a success.
 * - connection.success: Successful connection event.
 * - connection.error: Connection failure.
 *
 * @param settings {Object} Configuration.
 * @param settings.exchange {String} Unique name for the work exchange, defaults to &quot;node-rabbit&quot;.
 * @param settings.api {String} URL to RabbitMQ management API, if available.
 *
 * @param cb {Function} Callback function, optional. May also bind listener to &quot;connection&quot;, &quot;connection.success&quot; or &quot;connection.error&quot; events.
 * @returns {Rabbit} Newly created Rabbit instance.
 * @async
 * @chainable
 * @constructor
 */
function Rabbit( settings, cb ) {
  Rabbit.debug( &#x27;Creating new connection.&#x27; );

  // Make sure context is correct otherwise we could screw up the global scope.
  if( !( this instanceof Rabbit ) ) {
    return new Rabbit( settings, cb );
  }

  var Instance = this;

  // Mixin Settings and EventEmitter
  require( &#x27;object-settings&#x27; ).mixin( Instance );
  require( &#x27;object-emitter&#x27; ).mixin( Instance );

  // Configure instance.
  Instance.set({
    settings: Rabbit.extend( {}, Rabbit.defaults, settings ),
    options: {
      job_subscription: {
        prefetchCount: 10,
        ack: true
      },
      correlation_subscription: {
        prefetchCount: 10,
        ack: true
      },
    },
    environment: &#x27;production&#x27;,
    exchange: {},
    identity: String( process.pid )
  });

  // Connect to AMQP.
  this.connection = Rabbit.amqp.createConnection({
    host: Instance.get( &#x27;settings.host&#x27; ),
    port: Instance.get( &#x27;settings.port&#x27; ),
    login: Instance.get( &#x27;settings.login&#x27; ),
    password: Instance.get( &#x27;settings.password&#x27; ),
    vhost: Instance.get( &#x27;settings.vhost&#x27; )
  }, {
    defaultExchangeName: Instance.get( &#x27;settings.defaultExchange&#x27;, &#x27;&#x27; ),
    reconnect: Instance.get( &#x27;settings.reconnect&#x27;, true ),
  });

  // Bind callback to ready event, if provided.
  if( &#x27;function&#x27; === typeof cb ) {
    this.on( &#x27;ready&#x27;, cb );
  }

  // RabbitMQ connection failed.
  this.connection.on( &#x27;error&#x27;, function rabbit_error( error ) {
    Instance.emit( &#x27;connection&#x27;, new Error( error.message ), Instance );
    Instance.emit( &#x27;connection.error&#x27;, new Error( error.message ), Instance );
  });

  // RabbitMQ connection established.
  this.connection.on( &#x27;ready&#x27;, function rabbit_ready( connection ) {

    // Exchange Options.
    var _options = {
      type: &#x27;direct&#x27;,
      passive: false,
      durable: true,
      autoDelete: true,
      arguments: {
        created: new Date().getTime()
      }
    }

    // Create/Update Exchange.
    this.exchange( Instance.get( &#x27;settings.exchange&#x27; ), _options, function have_exchange() {

      // Set Exchange Variables.
      Instance.set( &#x27;exchange&#x27;, this );

      // Emit connection success.
      Instance.emit( &#x27;connection&#x27;, null, Instance );
      Instance.emit( &#x27;connection.success&#x27;, Instance );

    });

  });

  // Return context.
  return this;

}

// Rabbit prototype properties.
Object.defineProperties( Rabbit.prototype, {
  configure: {
    /**
     * Configure Client
     *
     * Method executed when connection is ready.
     * Usage and semantics emulating Express.
     *
     * @param env
     * @param fn
     * @returns {*}
     */
    value: function configure( env, fn ) {
      var Instance  = this;
      var envs      = &#x27;all&#x27;;
      var args      = [].slice.call(arguments);

      fn = args.pop();

      if( args.length ) {
        envs = args;
      }

      if( &#x27;all&#x27; == envs || ~envs.indexOf( this.get( &#x27;environment&#x27; ) ) ) {
        Instance.on( &#x27;connection.success&#x27;, fn.bind( this, this ) );
      }

      return this;

    },
    enumerable: true,
    writable: true,
    configurable: true
  },
  registerJob: {
    /**
     * Define a job.
     *
     * @param name {String} Name of job type.
     * @param fn {Function} Function to process job.
     */
    value: function registerJob( type, fn ) {

      var Instance = this;

      if( &#x27;function&#x27; !== typeof fn ) {
        Rabbit.debug( new Error( &#x27;The second argument of registerJob() must be a function.&#x27; ) );
        return this;
      }

      // Job Queue Options.
      var _options = {
        durable: true,
        autoDelete: false,
        passive: false,
        arguments: {
          routing_key: [ &#x27;job&#x27;, type ].join( &#x27;.&#x27; ),
          type: type
        }
      };

      // Use the default &#x27;amqueue.topic&#x27; exchange
      this.connection.queue( _options.arguments.routing_key, _options, function have_queue( queue ) {
        Rabbit.debug( &#x27;Monitoring [%s/%s].&#x27;, Instance.get( &#x27;exchange.name&#x27; ), _options.arguments.routing_key );

        // Bind to exchange with routing of &quot;job&quot;
        queue.bind( Instance.get( &#x27;exchange.name&#x27; ), _options.arguments.routing_key );

        // Receive messages
        queue.subscribe( Instance.get( &#x27;options.job_subscription&#x27; ), function have_message( message, headers, info ) {

          // Acknowledge Receipt.
          if( Instance.get( &#x27;options.job_subscription&#x27; ).ack ) {
            queue.shift();
          }

          // Create Job Instance.
          var job = Rabbit.Job.create({
            id: info.messageId,
            type: info.type,
            client: info.replyTo,
            message: message,
            format: info.contentType,
            routing: info.routingKey,
            correlation_key: headers.correlation_key,
            meta: {
              exchange: info.exchange,
              appId: info.appId,
              correlation: info.correlationId,
              mode: info.deliveryMode,
              consumer: info.consumerTag,
              redelivered: info.redelivered,
            },
            queue: queue,
            headers: headers,
            exchange: Instance.get( &#x27;exchange&#x27; ),
            rabbit: Instance
          })

          // Call the Job Worker callback.
          fn.call( job, job.message, function complete_wrapper( error, response ) {
            job.complete( error, response )
          });

        });

      });

    },
    enumerable: true,
    writable: true,
    configurable: true
  },
  runJob: {
    /**
     * Run a job.
     *
     * @method runJob
     * @chainable
     * @param job_type {String} Name of job type.
     * @param message {Object} Job data.
     * @param response {Function} Callback method.
     */
    value: function runJob( job_type, message, response ) {

      if( &#x27;function&#x27; !== typeof response ) {
        return new Error( &#x27;Response must be a method&#x27; );
      }

      var Instance            = this;

      var correlation         = Rabbit.Correlation.create({
        sid: Math.random().toString( 36 ).substring( 2 ),
        mid: Math.random().toString( 36 ).substring( 2 ),
        format: &#x27;application/json&#x27;,
        job_key: [ &#x27;job&#x27;, job_type ].join( &#x27;.&#x27; ),
        job_type: job_type
      });

      this.get( &#x27;exchange&#x27; ).publish( correlation.job_key, message, {
        correlationId : correlation.id,
        type: correlation.job_key,
        messageId: correlation.mid,
        replyTo: correlation.sid,
        contentType: correlation.format,
        deliveryMode: 2,
        appId: this.get( &#x27;identity&#x27; ),
        headers: {
          correlation_key: correlation.key,
          job_type: job_type
        }
      });

      // Create exclusive (Correlation) queue options.
      var _options = {
        durable: true,
        exclusive: true,
        autoDelete: true,
        passive: false,
        arguments: {
          job_key: correlation.job_key,
          job_type: correlation.job_type
        }
      };

      // Use the default &#x27;amqueue.topic&#x27; exchange
      this.connection.queue( correlation.key, _options, function have_correlation_queue( queue ) {
        Rabbit.debug( &#x27;Created Correlation Queue [%s] for job key [%s].&#x27;, correlation.key, correlation.job_key )

        // Start Response correlation stream.
        response.call( correlation );

        // Bind to exchange with direct routing.
        queue.bind( Instance.get( &#x27;exchange.name&#x27; ), correlation.key );

        // Receive a correlation message.
        queue.subscribe( Instance.get( &#x27;options.correlation_subscription&#x27; ), function have_correlation_message( message, headers, info ) {
          Rabbit.debug( &#x27;Received Correlation Queue (QC) [%s] job response type: [%s].&#x27;, headers.correlation_key, headers.event )

          // Emit a correlation event.
          correlation.emit( headers.event, message, {
            id: info.messageId,
            message: message,
            format: info.contentType,
            headers: headers
          });

          // Destroy Correlation Queue on completion.
          if( headers.event === &#x27;complete&#x27; ) {

            queue.destroy({
              ifUnused: false,
              ifEmpty: false
            });

          }

        });

      });

      // @chainable.
      return this;

    },
    enumerable: true,
    writable: true,
    configurable: true
  },
  define: {
    get: function() { return this.registerJob },
    enumerable: false,
    configurable: true
  },
  run: {
    get: function() { return this.runJob },
    enumerable: false,
    configurable: true
  },
  api: {
    /**
     * Make RabbitMQ API Request
     *
     * @example
     *
     *    // Get Vhosts
     *    Instance.api( &#x27;get&#x27;, &#x27;vhosts&#x27;, console.log );
     *
     *    // Get queues
     *    Instance.api( &#x27;get&#x27;, &#x27;queues&#x27;, console.log );
     *
     * @async
     * @chainable
     * @param method
     * @param query
     * @param cb
     */
    value: function api( method, query, cb ) {

      Rabbit.request({
        url: Instance.get( &#x27;settings.api&#x27; ) + &#x27;/vhosts&#x27;,
        json: true,
        auth: {
          user: Instance.get( &#x27;settings.login&#x27; ),
          pass: Instance.get( &#x27;settings.password&#x27; )
        }
      }, function( error, req, body ) { cb( error, body ); });

      // Chainable.
      return this;

    },
    enumerable: true,
    writable: true,
    configurable: true
  }
});

// Rabit constructor properties.
Object.defineProperties( module.exports = Rabbit, {
  Job: {
    value: require( &#x27;./job&#x27; ),
    enumerable: true,
    writable: true,
    configurable: true
  },
  Correlation: {
    value: require( &#x27;./correlation&#x27; ),
    enumerable: true,
    writable: true,
    configurable: true
  },
  debug: {
    value: require( &#x27;debug&#x27; )( &#x27;rabbit&#x27; ),
    enumerable: false,
    writable: true,
    configurable: true
  },
  request: {
    value: require( &#x27;request&#x27; ),
    enumerable: false,
    writable: true,
    configurable: true
  },
  extend: {
    value: require( &#x27;extend&#x27; ),
    enumerable: false,
    writable: true,
    configurable: true
  },
  amqp: {
    value: require( &#x27;amqp&#x27; ),
    enumerable: false,
    writable: true,
    configurable: true
  },
  defaults: {
    value: {
      exchange: &#x27;node-rabbit&#x27;,
      host: &#x27;localhost&#x27;,
      port: 5672,
      login: &#x27;guest&#x27;,
      password: &#x27;guest&#x27;,
      vhost: &#x27;/&#x27;,
      reconnect: true,
      api: &#x27;http://localhost:15672/api&#x27;
    },
    enumerable: false,
    writable: true,
    configurable: true
  },
  createConnection: {
    /**
     * Returns new instance of Rabbit.
     *
     * @param settings {Object} Configuration for connection.
     * @returns {Rabbit}
     */
    value: function createConnection ( settings, cb ) {
      return new Rabbit( settings, cb );
    },
    enumerable: true,
    writable: true,
    configurable: true
  }
});





    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
